import pandas as pd
import numpy as np
import re
import traceback
import logging
from collections import defaultdict

logging.basicConfig(
    filename='rule_conversion.log',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

def clean_name(text):
    cleaned = re.sub(r'[^a-z0-9_]', '_', str(text).strip().lower())
    return re.sub(r'_+', '_', cleaned)

def parse_formula(formula: str):
    """Parse formulas with +, -, *, / operators"""
    try:
        # Remove spaces and split into components
        formula = formula.replace(" ", "")
        left, right = formula.split("=")
        target = clean_name(left.strip())
        
        # Check all supported operators
        for operator in ['+', '-', '*', '/']:
            if operator in right:
                parts = right.split(operator)
                if len(parts) != 2:
                    raise ValueError(f"Invalid operator usage in {formula}")
                
                # Handle numeric multipliers for * and /
                if operator in ['*', '/']:
                    for i in [0, 1]:
                        if parts[i].replace('.', '', 1).isdigit():
                            return {
                                "target": target,
                                "operator": operator,
                                "left": clean_name(parts[1-i]),
                                "right": float(parts[i])
                            }
                    # If no numbers found, treat as variable-operator-variable
                    return {
                        "target": target,
                        "operator": operator,
                        "left": clean_name(parts[0]),
                        "right": clean_name(parts[1])
                    }
                else:  # + or -
                    return {
                        "target": target,
                        "operator": operator,
                        "left": clean_name(parts[0]),
                        "right": clean_name(parts[1])
                    }
        
        raise ValueError(f"No supported operator found in {formula}")
    
    except Exception as e:
        raise ValueError(f"Invalid formula: {formula} ‚Äî {str(e)}")

def build_custom_rules(df):
    custom_rules = defaultdict(list)
    skipped = []

    for _, row in df.iterrows():
        try:
            raw_formula = row["Typical Formula"]
            parsed = parse_formula(raw_formula)
            
            # Build formula string
            if isinstance(parsed["right"], float):
                formula = f"{parsed['left']} {parsed['operator']} {parsed['right']}"
            else:
                formula = f"{parsed['left']} {parsed['operator']} {parsed['right']}"

            custom_rules[parsed["target"]].append({
                "formula": formula,
                "tolerance": float(row["Tolerance"]) if pd.notna(row["Tolerance"]) else 0.0,
                "notes": row.get("Notes", "").strip()
            })

            logging.info(f"‚úîÔ∏è Rule parsed: {parsed['target']} = {formula}")

        except Exception as e:
            msg = f"‚õî Skipping: {raw_formula} ‚Äî {str(e)}"
            logging.warning(msg)
            skipped.append(msg)

    return custom_rules, skipped

# Rest of your code remains the same
def generate_fashion_rules():
    try:
        print("üìÇ Loading Excel files...")
        rules_df = pd.read_excel("data/measurement_relationships.xlsx")
        desc_df = pd.read_excel("data/measurement_descriptions.xlsx")

        print("üîç Building rules from formulas...")
        rule_dict, skipped = build_custom_rules(rules_df)

        print("üìù Mapping descriptions...")
        desc_map = desc_df.set_index("Measurement Name")["Description"].to_dict()

        print("üíæ Writing fashion_rules.py...")
        with open("fashion_rules.py", "w", encoding="utf-8") as f:
            f.write("# AUTOGENERATED FILE\n\n")
            f.write("MEASUREMENT_DESCRIPTIONS = {\n")
            for key, val in desc_map.items():
                f.write(f'    "{clean_name(key)}": """{val}""",\n')
            f.write("}\n\n")

            f.write("CUSTOM_RULES = {\n")
            for target, rules in rule_dict.items():
                f.write(f'    "{target}": [\n')
                for rule in rules:
                    f.write("        {\n")
                    f.write(f'            "formula": "{rule["formula"]}",\n')
                    f.write(f'            "tolerance": {rule["tolerance"]},\n')
                    f.write(f'            "notes": """{rule["notes"]}"""\n')
                    f.write("        },\n")
                f.write("    ],\n")
            f.write("}\n")

        print(f"‚úÖ Created {len(rule_dict)} measurements with rules.")
        if skipped:
            print(f"‚ö†Ô∏è Skipped {len(skipped)} rules. Check rule_conversion.log.")

    except Exception as e:
        print(f"‚ùå ERROR: {e}")
        traceback.print_exc()

if __name__ == "__main__":
    print("üöÄ Starting Excel-to-Rules conversion...")
    generate_fashion_rules()
    print("üèÅ Done!")